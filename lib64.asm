    section .text

; Подпрограмма преобразования строки в число.
; Ограничение: число должно находиться в интервале -30000 ≤ x ≤ 30000.
; Вход: RSI – адрес строки, содержащей запись числа (положительные числа
; вводятся без знака), в конце введенной строки символ «10».
; Выход: EAX – 32-х разрядное число, RBX – 0, если преобразование прошло
; без ошибок, и 1, если в процессе преобразования обнаружен ввод
; недопустимого символа или введенное число не попадает в заданный интервал.

StrToInt64:
         push   rdi
         mov    bh, '9'
         mov    bl, '0'
         push   rsi     ; сохраняем адрес исходной строки
         cmp    byte[rsi], '-'
         jne    .prod
         inc    rsi     ; пропускаем знак минус
.prod    cld
         xor    di, di  ; обнуляем будущее число
.cycle:  lodsb          ; загружаем символ (цифру)
         cmp    al, 10  ; если 10, то на конец
         je     .Return
         cmp    al, bl  ; сравниваем с кодом нуля
         jb     .Error  ; "ниже" – Ошибка
         cmp    al, bh  ; сравниваем с кодом девяти
         ja     .Error  ; "выше" – Ошибка
         sub    al, 30h ; получаем цифру из символа
         cbw            ; расширяем до слова
         push   ax      ; сохраняем в стеке
         mov    ax, 10  ; заносим 10 в AX
         mul    di      ; умножаем, результат в DX:AX
         pop    di      ; в DI – очередная цифра
         add    ax, di
         mov    di, ax  ; в DI – накопленное число
         jmp    .cycle
.Return: pop    rsi
         mov    rbx, 0
         cmp    byte[rsi], '-'
         jne    .J
         neg    di
.J       mov    ax, di
         cwde
         jmp    .R
.Error:  pop    rsi
         mov    rax, 0
         mov    rbx, 1
.R       pop    rdi
         ret

; Подпрограмма преобразования числа в строку.
; Ограничение: числа в интервале -30000 ≤ x ≤ 30000.
; Вход: EAX – число, RSI – адрес области памяти для размещения строки
; результата (не менее 7 байт).
; Выход: RAX – размер строки результата, запись числа будет прижата к
; левой границе области по адресу RSI, после числа будет вставлен символ с кодом 10.

IntToStr64: 
         push   rdi
         push   rbx
         push   rdx
         push   rcx
		 push   rsi
		 mov    byte[rsi],0     ; на место знака
         cmp    eax,0
         jge    .l1
         neg    eax
         mov    byte[rsi],'-'
.l1      mov    byte[rsi+6],10
         mov    rdi,5
         mov    bx,10
.again:  cwd                    ; расширили слово до двойного
         div    bx              ; делим результат на 10
         add    dl,30h          ; получаем из остатка код цифры
         mov    [rsi+rdi],dl    ; пишем символ в строку
         dec    rdi             ; переводим указатель на 
                                ; предыдущую позицию
         cmp    ax, 0           ; преобразовали все число?
         jne    .again
         mov    rcx, 6
         sub    rcx, rdi        ; длина результата+знак
		 mov    rax,rcx
		 inc    rax             ; длина результата+знак+0А
         inc    rsi             ; пропускаем знак
		 push   rsi
         lea    rsi,[rsi+rdi]   ; начало символов результата
		 pop    rdi
         rep movsb
         pop    rsi  
         pop    rcx
         pop    rdx
         pop    rbx
         pop    rdi
         ret
